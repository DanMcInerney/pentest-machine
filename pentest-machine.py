#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import time
import signal
import argparse
import requests
import subprocess
import concurrent.futures as cf
from urlparse import urlparse
from selenium import webdriver
from selenium.common.exceptions import WebDriverException
from subprocess import Popen, STDOUT, PIPE
from multiprocessing import Process, Pool, Manager, Queue
from requests_futures.sessions import FuturesSession
from libnmap.process import NmapProcess
from libnmap.parser import NmapParser, NmapParserException
requests.packages.urllib3.disable_warnings()
# Debug
#from IPython import embed

# Globals
EYEWITNESS_RAN = False

class c:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def parse_args():
    # Create the arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-x", "--nmapxml", help="Nmap XML file to parse")
    parser.add_argument("-l", "--hostlist", help="Host list file")
    parser.add_argument("-w", "--workers", type=int, default=5, help="Number of parallel workers")
    parser.add_argument("--no-brute", help="Skip all bruteforce attacks", action="store_true")
    parser.add_argument("-s", "--skip", help="Skip any command or service separated by commas, e.g: --skip dirb,wpscan,snmp,http")
    return parser.parse_args()

def make_output_dirs():
    '''
    Create output directories
    '''
    dirs = ['output-by-host', 'output-by-service', 'output-by-cmd']
    for d in dirs:
        if not os.path.exists(d):
            os.makedirs(d)

def enqueue_cmds(queue, hosts, urls):
    '''
    Gather the commands to run
    '''

    hostnames = []
    hostname = None
    cmds = []
    cmd_strs = []

    for host in report.hosts:
        ip = host.address
        if host.is_up():
            # Each cmd = {service_str:[(cmd_string1, ip, service, bruteforce, slow_running)]}
            cmds += get_cmds_per_host(host, ip, urls, args)

    #Sort the commands so the fastest are at the front of the list
    # x[4] is boolean, True for slow running, False for fast running
    sorted_cmds = sorted(cmds, key=lambda x:x[4])

    for c in sorted_cmds:
        cmd_strs.append(c[0])
        queue.put(c)

    return cmd_strs

def get_cmds_per_host(host, ip, urls, args):
    '''
    For each service type, add commands to run against it
    '''
    # cmds = {service_str:[(cmd_string1, ip, service, bruteforce, slow_running)]}
    cmds = []

    if args.nmapxml:
        xml = args.nmapxml
    else:
        xml = os.getcwd()+'/pm-nmap.xml'

    for s in host.services:
        port = str(s.port)

        if 'open' == s.state:
            cmd_data_list = get_serv_cmds(s.service, ip, port, urls, xml)
            if len(cmd_data_list) > 0:
                for c in cmd_data_list:
                    cmd_data = filter_cmds(c, port, args)
                    if cmd_data:
                        cmds.append(cmd_data)

    return cmds

def filter_cmds(cmd_data, port, args):
    '''
    Remove unnecessary commands
    '''
    cmd_str = cmd_data[0]
    svc_str = cmd_data[2]

    # User-defined command skip
    if args.skip:
        # Split them at commas
        to_skip = args.skip.split(',')
        for c in to_skip:
            c = c.lower()
            # cmd_str.split()[0] should be stuff like "/usr/bin/nmap"
            if c in cmd_str.split()[0].lower() or c == svc_str.lower():
                return

    # Skip brute force if necessary
    if args.no_brute == True:
        if cmd_data[3] == True:
            return

    # RPC
    # only do showmount if it's an NFS port
    if '/sbin/showmount' in cmd_str:
        if port not in ['111', '2049']:
            return

    return cmd_data

def get_serv_cmds(service, ip, port, urls, xml):
    '''
    List of cmds to run on a per-service basis
    serv_cmds = {service_str:[(cmd_string, ip, service, bruteforce, slow_running)]}
    '''
    # Make sure we only run eyewitness once
    global EYEWITNESS_RAN

    cmds = []
    ip_port = '{0}:{1}'.format(ip, port)

    serv_cmds = {'ftp':[('tools/patator/patator.py ftp_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 3 port={1} --threads 4'.format(ip, port), ip_port, 'FTP', True, True)],

                 # Eventually add bruteforce against SMTP by first doing smtp_vrfy brute then using those SNs to attack
                 'smtp':[('/usr/bin/nmap -sSV -Pn -n -pT{0} --script smtp-enum-users,smtp-open-relay {1}'.format(port, ip), ip_port, 'SMTP', True, True)],

                 'postgre':[('tools/patator/patator.py postgresql_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 2'.format(ip), ip_port, 'Postgres', True, True)],

                 'mysql':[('tools/patator/patator.py mysql_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 3 --threads 2'.format(ip), ip_port, 'MYSQL', True, True)],

                 'ms-sql':[('tools/patator/patator.py mssql_login host={0} port={1} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
--max-retries 3 --threads 2'.format(ip, port), ip_port, 'MSSQL', True, True)],

                 'ssh':[('tools/patator/patator.py ssh_login host={0} user=COMBO00 password=COMBO01 0=wordlists/long-user-pass.list \
port={1} --max-retries 4 --threads 5'.format(ip, port), ip_port, 'SSH', True, True)],

                 'snmp':[('tools/patator/patator.py snmp_login host={0} port={1} community=FILE0 0=wordlists/112-snmp.list --threads 3'.format(ip, port), ip_port, 'SNMP', True, False)],

                 'rpc':[('/sbin/showmount -e {0}'.format(ip), ip_port, 'RPC', False, False)],

                 'smb|microsoft-ds':[('tools/enum4linux/enum4linux.pl -a {0}'.format(ip), ip_port, 'SMB', False, False),
                                     ('/usr/bin/nmap -sSV -p{0} --script smb-vuln-ms08-067,smb-vuln-ms17-010 {1}'.format(port, ip), ip_port, 'SMB', False, False)],

                                                                                   # These are the only two rdp scripts
                 'ms-wbt-server':[('/usr/bin/nmap -sSV -Pn -n -p{0} --script rdp-enum-encryption,rdp-vuln-ms12-020 {1}'.format(port, ip), ip_port, 'RDP', False, False)],

                 'ntp':[('/usr/bin/nmap -sUV -Pn -n -p{0} --script ntp-monlist {1}'.format(port, ip), ip_port, 'NTP', False, False)],

                 'sip':[('/usr/bin/nmap -sSV -Pn -n -p{0} --script sip-enum-users,sip-methods {1}'.format(port, ip), ip_port, 'SIP', False, False),
                        ('tools/sipvicious/sipvicious/svmap.py -p{0} {1}'.format(port, ip), ip_port, 'SIP', False, False)],

                 'domain':[('/usr/bin/nmap -sUV -Pn -n -p{0} --script dns-zone-transfer,dns-recursion {1}'.format(port, ip), ip_port, 'DNS', False, False)],

                 'http|www|ssl':http_cmds}

    for serv in serv_cmds:

        # If the service string in s.service
        if re.search(serv, service):

            # Add eyewitness for any scan that has http or RDP ports open
            if 'http|www|ssl' == serv or 'ms-wbt-server' == serv:
                if EYEWITNESS_RAN == False:
                    folder_name = 'eyewitness_'+str(int(time.time()))
                    cmds += [('tools/EyeWitness/EyeWitness.py -d {0} --threads 5 --ocr --no-prompt --active-scan --all-protocols --web -x {1}'.format(folder_name, xml), ip_port, 'HTTP', False, True)]
                    EYEWITNESS_RAN = True

            # Add HTTP commands
            if 'http|www|ssl' == serv:
                cmds += serv_cmds[serv](ip_port, urls)

            # Add all other commands
            else:
                cmds += serv_cmds[serv]

    return cmds

def http_cmds(ip_port, urls):
    '''
    Form all the commands to run against HTTP services
    and add them to the Queue
    Runs: whatweb, eyewitness, dirb
    '''
    cmds = []
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    for url in urls:

        if ip_port in url:

            # WhatWeb
            whatweb = 'tools/WhatWeb/whatweb {0}'.format(url)
            cmds.append((whatweb, ip_port, 'HTTP', False, False))

            # Directory bruteforcing
            dirb = 'tools/dirb {0} {1}'.format(url, 'wordlists/dirs-1800.list')
            cmds.append((dirb, ip_port, 'HTTP', True, True))

            # EyeWitness and autologin
            #ew = 'tools/EyeWitness/EyeWitness.py --no-prompt --active-scan --all-protocols --web -x {}'

    return cmds

def get_urls(report):
    '''
    Create, then asynchronously test all the valid URLs based on http/https and ip/hostname
    '''

    # Create all potential URLs from the IP and hostname
    potential_urls = get_potential_urls(report)

    # Start asynchronous requests to the potential URLs
    resps = resps_from_urls(potential_urls)

    # Get the results from the requests to the potential URLs
    working_urls = get_working_urls(resps)

    return working_urls

def get_working_urls(resps):
    '''
    Test each potential URL for a valid resp
    '''
    working_urls = []
    print '\n[*] Asynchronously gathering valid URLs...'
    for resp in cf.as_completed(resps):
        try:
            url = resp.result().url
            if resp.result().status_code != 404:
                if url not in working_urls:
                    working_urls.append(url)
        except Exception as e:
            # Uncomment to see reason for failure, but not URL (SSL errors prevent rep.result().url)
            #print '[-]   {}'.format(str(e))
            continue

    # Eliminate URL paths so it's just the host and port, can have a path if it redirects
    working_urls = clean_working_urls(working_urls)

    print ''
    return working_urls

def clean_working_urls(working_urls):
    '''
    If the URL redirects with a path, we need to eliminate the path
    '''
    rm_path_urls = []
    for u in working_urls:
        parsed = urlparse(u)
        new_url = parsed.scheme+'://'+parsed.netloc
        if new_url not in rm_path_urls:
            print '[+]   {}'.format(new_url)
            rm_path_urls.append(new_url)

    return rm_path_urls

def get_potential_urls(report):
    '''
    Print all the hosts and services per host
    Create all potential URL combinations from the nmap IP/hostname
    '''
    potential_urls = []

    for host in report.hosts:
        ip = host.address
        if host.is_up():
            print '\n[+] Host: {0}'.format(ip)
            for s in host.services:
                port = str(s.port)
                if 'open|filtered' not in s.state:
                    # Print all the open ports
                    print '[*]   {0}/{1} {2} {3}'.format(port, s.protocol, s.state, s.service)
                    ip_port = '{0}:{1}'.format(ip, port)
                    # Set protocol to http:// by default and adjust to https:// when
                    # 'https' or 'ssl' in service name
                    if re.search('http|www|ssl', s.service):
                        protocol = 'http://'
                        # Check for https and ssl so we can change the protocol
                        if re.search('https|ssl', s.service) or port == '443':
                            protocol = 'https://'
                        url = '{0}{1}'.format(protocol, ip_port)
                        potential_urls.append(url)

    return potential_urls

def resps_from_urls(potential_urls):
    '''
    Gather valid responses from the list of potential urls
    '''
    resps = []
    session = FuturesSession(max_workers=30)
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0'}

    for url in potential_urls:
        resp = session.get(url, timeout=25, verify=False, headers=headers)
        resps.append(resp)

    return resps


def worker(lock, queue, proc_monitor):
    '''
    Multiprocessing worker that actually runs the commands
    '''
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    pid = os.getpid()

    #while queue.qsize() > 0:
    while 1:
        waiting_for_item = True

        # Necessary to catching CTRL-C
        try:
            # This has to wait for write_output() and causes IOError sometimes on CTRL-C
            proc_monitor[pid] = waiting_for_item
            # This causes EOFError on CTRL-C
            cmd_data = queue.get()
        except (EOFError, IOError):
            return

        # Tells the shared dict proc_monitor that we are performing actions
        # based on a queue object so don't finish the script yet
        proc_monitor[pid] = False
        cmd = cmd_data[0]
        cmd_list = cmd.split()
        ip_port = cmd_data[1]
        split = ip_port.split(':')
        ip = split[0]
        port = split[1]
        service = cmd_data[2]

        out = run_cmd(cmd_list, cmd, ip)
        out = adjust_output(cmd_list, out)

        # On Ctrl-C will throw IOError if it came while writing
        try:
            if out:
                write_output(lock, cmd, ip, service, out)
        except IOError:
            return

        # Add new cmds
        add_new_cmds(queue, cmd_list, ip_port, out)

def run_cmd(cmd_list, cmd, ip):
    '''
    Run either the OS command or call a function based on cmd_data
    '''
    out = None

    print '[*] Running command: {0}'.format(cmd)
    proc = Popen(cmd_list, stdout=PIPE, stderr=STDOUT)
    out = proc.communicate()[0].strip()

    return out

def write_output(lock, full_cmd, ip, service, out):
    '''
    Write each cmd's output to a file named by the IP and a file named by the service type
    '''
    split_cmd = full_cmd.split()

    # Narrow down the full cmd to just the base program name
    cmd = split_cmd[0]
    # For when it's like /usr/bin/nmap
    if '/' in cmd:
        cmd = cmd.split('/')[-1]

    with lock:
        msg = '\n[+] OUTPUT: {0}\n{1}'.format(full_cmd, out)
        print msg

        with open('output-by-host/{0}.txt'.format(ip), 'a+') as f:
            f.write(msg)
        with open('output-by-service/{0}.txt'.format(service), 'a+') as f:
            f.write(msg)
        with open('output-by-cmd/{0}.txt'.format(cmd), 'a+') as f:
            f.write(msg)

def adjust_output(cmd_list, out):
    '''
    Remove output from cmds with too much of it and remove errors from some cmds' output
    '''
    # Skip certain output lines
    adjusted_out = ''

    for l in out.splitlines():

        # Skip dirb crap
        if 'tools/dirb' in cmd_list[0]:
            # Make sure the line has at least some findings
            if ' (CODE:' in l or '==> DIRECTORY' in l:
                parts = l.split('\r')
                for p in parts:
                    line = p.strip()
                    if len(line) > 0 and '--> Testing:' not in line and 'Calculating NOT_FOUND' not in line:
                        if line + '\n' not in adjusted_out:
                            adjusted_out += line + '\n'

        # Highlight found password in MySQL brute
        elif 'mysql_login' in cmd_list[1]:
            if 'INFO - 0 ' in l:
                pw_found = '\n\n\n******************************** PASSWORD FOUND ********************************\n'
                pw_found2 = '\n******************************** PASSWORD FOUND ********************************\n\n\n'
                adjusted_out += pw_found + l + pw_found2
            else:
                adjusted_out += l + '\n'


        # Skip error line in whatweb
        elif 'WhatWeb' in cmd_list[0]:
            if 'iconv will be deprecated in the future' not in l:
                adjusted_out += l + '\n'

        else:
            if l.strip() != '':
                adjusted_out += l + '\n'

    # Escape colors like whatweb has
    ansi_escape = re.compile(r'\x1b[^m]*m')
    out = ansi_escape.sub('', adjusted_out)

    return out

def nmap_scan(hosts):
    '''
    Do Nmap scan
    '''
    # This is top 1000 tcp + top 50 UDP scan
    # Nmap has chosen not to do --top-udp/tcp-ports options due to not wanting to overcomplicate
    # the cmd line interface
    nmap_args = '-sSUV -v --reason -T4 --max-retries 3 --max-rtt-timeout 150ms -pT:1,3-4,6-7,9,13,17,19-26,30,32-33,37,42-43,49,53,70,79-85,88-90,99-100,106,109-111,113,119,125,135,139,143-144,146,161,163,179,199,211-212,222,254-256,259,264,280,301,306,311,340,366,389,406-407,416-417,425,427,443-445,458,464-465,481,497,500,512-515,524,541,543-545,548,554-555,563,587,593,616-617,625,631,636,646,648,666-668,683,687,691,700,705,711,714,720,722,726,749,765,777,783,787,800-801,808,843,873,880,888,898,900-903,911-912,981,987,990,992-993,995,999-1002,1007,1009-1011,1021-1100,1102,1104-1108,1110-1114,1117,1119,1121-1124,1126,1130-1132,1137-1138,1141,1145,1147-1149,1151-1152,1154,1163-1166,1169,1174-1175,1183,1185-1187,1192,1198-1199,1201,1213,1216-1218,1233-1234,1236,1244,1247-1248,1259,1271-1272,1277,1287,1296,1300-1301,1309-1311,1322,1328,1334,1352,1417,1433-1434,1443,1455,1461,1494,1500-1501,1503,1521,1524,1533,1556,1580,1583,1594,1600,1641,1658,1666,1687-1688,1700,1717-1721,1723,1755,1761,1782-1783,1801,1805,1812,1839-1840,1862-1864,1875,1900,1914,1935,1947,1971-1972,1974,1984,1998-2010,2013,2020-2022,2030,2033-2035,2038,2040-2043,2045-2049,2065,2068,2099-2100,2103,2105-2107,2111,2119,2121,2126,2135,2144,2160-2161,2170,2179,2190-2191,2196,2200,2222,2251,2260,2288,2301,2323,2366,2381-2383,2393-2394,2399,2401,2492,2500,2522,2525,2557,2601-2602,2604-2605,2607-2608,2638,2701-2702,2710,2717-2718,2725,2800,2809,2811,2869,2875,2909-2910,2920,2967-2968,2998,3000-3001,3003,3005-3007,3011,3013,3017,3030-3031,3052,3071,3077,3128,3168,3211,3221,3260-3261,3268-3269,3283,3300-3301,3306,3322-3325,3333,3351,3367,3369-3372,3389-3390,3404,3476,3493,3517,3527,3546,3551,3580,3659,3689-3690,3703,3737,3766,3784,3800-3801,3809,3814,3826-3828,3851,3869,3871,3878,3880,3889,3905,3914,3918,3920,3945,3971,3986,3995,3998,4000-4006,4045,4111,4125-4126,4129,4224,4242,4279,4321,4343,4443-4446,4449,4550,4567,4662,4848,4899-4900,4998,5000-5004,5009,5030,5033,5050-5051,5054,5060-5061,5080,5087,5100-5102,5120,5190,5200,5214,5221-5222,5225-5226,5269,5280,5298,5357,5405,5414,5431-5432,5440,5500,5510,5544,5550,5555,5560,5566,5631,5633,5666,5678-5679,5718,5730,5800-5802,5810-5811,5815,5822,5825,5850,5859,5862,5877,5900-5904,5906-5907,5910-5911,5915,5922,5925,5950,5952,5959-5963,5987-5989,5998-6007,6009,6025,6059,6100-6101,6106,6112,6123,6129,6156,6346,6389,6502,6510,6543,6547,6565-6567,6580,6646,6666-6669,6689,6692,6699,6779,6788-6789,6792,6839,6881,6901,6969,7000-7002,7004,7007,7019,7025,7070,7100,7103,7106,7200-7201,7402,7435,7443,7496,7512,7625,7627,7676,7741,7777-7778,7800,7911,7920-7921,7937-7938,7999-8002,8007-8011,8021-8022,8031,8042,8045,8080-8090,8093,8099-8100,8180-8181,8192-8194,8200,8222,8254,8290-8292,8300,8333,8383,8400,8402,8443,8500,8600,8649,8651-8652,8654,8701,8800,8873,8888,8899,8994,9000-9003,9009-9011,9040,9050,9071,9080-9081,9090-9091,9099-9103,9110-9111,9200,9207,9220,9290,9415,9418,9485,9500,9502-9503,9535,9575,9593-9595,9618,9666,9876-9878,9898,9900,9917,9929,9943-9944,9968,9998-10004,10009-10010,10012,10024-10025,10082,10180,10215,10243,10566,10616-10617,10621,10626,10628-10629,10778,11110-11111,11967,12000,12174,12265,12345,13456,13722,13782-13783,14000,14238,14441-14442,15000,15002-15004,15660,15742,16000-16001,16012,16016,16018,16080,16113,16992-16993,17877,17988,18040,18101,18988,19101,19283,19315,19350,19780,19801,19842,20000,20005,20031,20221-20222,20828,21571,22939,23502,24444,24800,25734-25735,26214,27000,27352-27353,27355-27356,27715,28201,30000,30718,30951,31038,31337,32768-32785,33354,33899,34571-34573,35500,38292,40193,40911,41511,42510,44176,44442-44443,44501,45100,48080,49152-49161,49163,49165,49167,49175-49176,49400,49999-50003,50006,50300,50389,50500,50636,50800,51103,51493,52673,52822,52848,52869,54045,54328,55055-55056,55555,55600,56737-56738,57294,57797,58080,60020,60443,61532,61900,62078,63331,64623,64680,65000,65129,65389,U:53,67-69,111,123,135,137-139,161-162,445,500,514,520,631,998,1434,1701,1900,4500,5353,49152,49154 -oA pm-nmap'
    print '[*] Running nmap'
    nmap_proc = NmapProcess(targets=hosts, options=nmap_args, safe_mode=False)
    rc = nmap_proc.sudo_run_background()
    while nmap_proc.is_running():
        print("[*] Nmap running...")
        time.sleep(30)

    report = NmapParser.parse_fromfile('pm-nmap.xml')

    return report

############################# ADD NEW CMDS #####################################################
def add_new_cmds(queue, cmd_list, ip_port, out):
    '''
    Based the output of one of the originally run cmds, add new cmds
    to the queue for the workers to process
    '''
    new_cmds = {'tools/WhatWeb/whatweb':add_wpscan,
               'snmp_login':add_snmpcheck}

    for cmd_snippet in new_cmds:
        if cmd_snippet in cmd_list:
            new_cmds[cmd_snippet](out, ip_port, queue, cmd_list)

def add_snmpcheck(out, ip_port, queue, cmd_list):
    '''
    Add snmpcheck to gather info from valid SNMP logins
    '''
    split = ip_port.split(':')
    ip = split[0]
    port = split[1]

    if 'snmp_login' in cmd_list:
        out_lines = out.splitlines()
        for l in out_lines:
            # 0-0 is the code and is only found on lines of output referring to a brute attempt
            if ' 0-0 ' in l:
                skip = ['PySnmpError', 'No SNMP reponse received', 'TimeoutError']
                if any(x in l for x in skip):
                    continue
                else:
                    split_line = l.split()
                    comm_str = split_line[8]
                    snmpcheck = 'tools/snmpcheck-1.9.rb {0} -c {1} -w -p {2}'.format(ip, comm_str, port)
                    queue.put((snmpcheck, ip_port, 'SNMP', False, False))
                    # Return because there should only be 1 winning community string
                    return

def add_wpscan(out, ip_port, queue, cmd_list):
    '''
    Add WPScan to queue if "wordpress" is in whatweb output
    '''
    if 'wordpress' in out.lower():
        url = cmd_list[1]
        wp = 'tools/wpscan/wpscan.rb --disable-tls-checks -r -u {0}'.format(url)
        wp_cmd = (wp, ip_port, 'HTTP', False, False)
        queue.put(wp_cmd)
        return
################################################################################################

def kill_procs(c):
    ps = subprocess.Popen(('ps', 'aux'), stdout=subprocess.PIPE)
    ps_out = ps.communicate()[0].splitlines()
    for l in ps_out:
        if 'grep ' not in l:
            if c in l:
                os.kill(int(l.split()[1]), signal.SIGKILL)

def remove_files():
    '''
    Remove the log files from eyewitness
    '''
    files = ['ghostdriver.log', 'parsed_xml.txt', 'geckodriver.log']
    for f in files:
        if os.path.isfile(f):
            os.remove(f)

def main(report, num_workers):
    '''
    Run through the hosts' available services appending their respective commands
    to a list, then have x number of workers run through those commands
    '''
    args = parse_args()
    # Can't just use multiprocessing.Lock() because you can't share locks between pool-created Processes
    m = Manager()
    lock = m.Lock()
    proc_monitor = m.dict()
    # Regular Queue() gets pickled and unpickled by each worker which means its copied so it can't be shareed between Procs
    queue = m.Queue()

    # Create output directories
    make_output_dirs()

    # Check web services for valid URLs
    urls = get_urls(report)

    # Enqueue all the cmds based on the services detected
    cmd_strs = enqueue_cmds(queue, report.hosts, urls)

    # Kick off the workers in the Pool
    pool = Pool(num_workers, worker, (lock, queue, proc_monitor))

    # Every second check if all the processes are waiting on the queue which would
    # mean all cmds are done and all are just infinitely waiting for a new task
    while 1:
        try:
            time.sleep(3)

            procs_waiting = []
            # Can't iterate over DictProxy with `for key in DictProxy`
            # which is what Manager().dict() is so gotta do this
            pids = iter(proc_monitor.keys())
            for p in pids:
                procs_waiting.append(proc_monitor[p])

            # If all procs are just waiting, then we're done
            if all(procs_waiting):
                pool.terminate()
                pool.join()
                remove_files()
                # Prevents terminal from breaking
                os.system('stty sane')
                return

        except KeyboardInterrupt:
            print '\n[-] Killing unfinished processes...'
            remove_files()
            pool.terminate()
            pool.join()
            # Kill remaining processes, {{}} values are ignored by .format()
            # Append the phantomjs cmd that gets called from selenium -- is this still necessary?
            cmd_strs.append('phantomjs --ignore-ssl-errors=true --ssl-protocol=tlsv1 --webdriver=')
            for c in cmd_strs:
                kill_procs(c)
            # Prevents terminal from breaking
            os.system('stty sane')
            sys.exit()


if __name__ == "__main__":

    args = parse_args()

    if os.geteuid():
        exit('[-] Please run as root')

    if args.nmapxml:
        report = NmapParser.parse_fromfile(args.nmapxml)
    elif args.hostlist:
        with open(args.hostlist, 'r') as hostlist:
            hosts = hostlist.read().split()
        report = nmap_scan(hosts)
    else:
        print 'Please use the "-x [nmapoutput.xml]" option if you already have an nmap XML file \
or "-l [hostlist.txt]" option to run an nmap scan with a hostlist file.'
        sys.exit()

    main(report, args.workers)
